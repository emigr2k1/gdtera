/// Run Alacritty.
///
/// Creates a window, the terminal state, PTY, I/O event loop, input processor,
/// config change monitor, and runs the main display loop.
fn run(window_event_loop: GlutinEventLoop<Event>, config: Config) -> Result<(), Box<dyn Error>> {
    info!("Welcome to Alacritty");

    match &config.config_path {
        Some(config_path) => info!("Configuration loaded from \"{}\"", config_path.display()),
        None => info!("No configuration file found"),
    }

    // Set environment variables.
    tty::setup_env(&config);

    let event_proxy = EventProxy::new(window_event_loop.create_proxy());

    // Create a display.
    //
    // The display manages a window and can draw the terminal.
    let display = Display::new(&config, &window_event_loop)?;

    info!("PTY dimensions: {:?} x {:?}", display.size_info.lines(), display.size_info.cols());

    // Create new native clipboard.
    #[cfg(not(any(target_os = "macos", windows)))]
    let clipboard = Clipboard::new(display.window.wayland_display());
    #[cfg(any(target_os = "macos", windows))]
    let clipboard = Clipboard::new();

    // Create the terminal.
    //
    // This object contains all of the state about what's being displayed. It's
    // wrapped in a clonable mutex since both the I/O loop and display need to
    // access it.
    let terminal = Term::new(&config, &display.size_info, clipboard, event_proxy.clone());
    let terminal = Arc::new(FairMutex::new(terminal));

    // Create the PTY.
    //
    // The PTY forks a process to run the shell on the slave side of the
    // pseudoterminal. A file descriptor for the master side is retained for
    // reading/writing to the shell.
    #[cfg(not(any(target_os = "macos", windows)))]
    let pty = tty::new(&config, &display.size_info, display.window.x11_window_id());
    #[cfg(any(target_os = "macos", windows))]
    let pty = tty::new(&config, &display.size_info, None);

    // Create the pseudoterminal I/O loop.
    //
    // PTY I/O is ran on another thread as to not occupy cycles used by the
    // renderer and input processing. Note that access to the terminal state is
    // synchronized since the I/O loop updates the state, and the display
    // consumes it periodically.
    let event_loop = EventLoop::new(Arc::clone(&terminal), event_proxy.clone(), pty, &config);

    // The event loop channel allows write requests from the event processor
    // to be sent to the pty loop and ultimately written to the pty.
    let loop_tx = event_loop.channel();

    // Create a config monitor when config was loaded from path.
    //
    // The monitor watches the config file for changes and reloads it. Pending
    // config changes are processed in the main loop.
    if config.live_config_reload() {
        config.config_path.as_ref().map(|path| Monitor::new(path, event_proxy.clone()));
    }

    // Setup storage for message UI.
    let message_buffer = MessageBuffer::new();

    // Event processor.
    let mut processor =
        Processor::new(event_loop::Notifier(loop_tx.clone()), message_buffer, config, display);

    // Kick off the I/O thread.
    let io_thread = event_loop.spawn();

    info!("Initialisation complete");

    // Start event loop and block until shutdown.
    processor.run(terminal, window_event_loop);

    // This explicit drop is needed for Windows, ConPTY backend. Otherwise a deadlock can occur.
    // The cause:
    //   - Drop for ConPTY will deadlock if the conout pipe has already been dropped.
    //   - The conout pipe is dropped when the io_thread is joined below (io_thread owns PTY).
    //   - ConPTY is dropped when the last of processor and io_thread are dropped, because both of
    //     them own an Arc<ConPTY>.
    //
    // The fix is to ensure that processor is dropped first. That way, when io_thread (i.e. PTY)
    // is dropped, it can ensure ConPTY is dropped before the conout pipe in the PTY drop order.
    //
    // FIXME: Change PTY API to enforce the correct drop order with the typesystem.
    drop(processor);

    // Shutdown PTY parser event loop.
    loop_tx.send(Msg::Shutdown).expect("Error sending shutdown to PTY event loop");
    io_thread.join().expect("join io thread");

    // FIXME patch notify library to have a shutdown method.
    // config_reloader.join().ok();

    // Without explicitly detaching the console cmd won't redraw it's prompt.
    #[cfg(windows)]
    unsafe {
        FreeConsole();
    }

    info!("Goodbye");

    Ok(())
}
